<!DOCTYPE html>
<html lang="ka">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>პრეფერანსი – მიზერი</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #065535, #00331e); 
            color: #f0f0f0;
            text-align: center;
            padding: 8px; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center; 
            overflow-x: hidden; 
        }

        h1 { 
            margin-bottom: 5px;
            font-size: 1.8em; 
            color: #ffeb3b;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        p {
            font-size: 0.9em; 
            margin-bottom: 8px;
        }

        /* Game Layout */
        #game {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 900px; 
            margin: 0 auto;
            gap: 10px; 
        }

        /* FLEX CONTAINER FOR WEST - BOARD - EAST */
        .middle-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            width: 100%;
            margin: 10px 0; 
        }

        .hand {
            padding: 3px; 
            border: 2px solid #aaa;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            min-height: 80px;
            display: flex;
            flex-direction: column;
            flex-grow: 1; 
        }

        /* MODIFIED WEST/EAST STYLES (COMPACT) */
        #west, #east {
            min-width: 100px; 
            max-width: 30%; 
            min-height: 140px; 
            height: auto; 
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 5px;
        }
        
        #west {
            align-items: flex-end; 
        }
        
        #east {
            align-items: flex-start; 
        }

        /* Card Groups Container */
        #west .cards, #east .cards {
            display: flex;
            flex-direction: column; 
            gap: 3px; 
            width: auto; 
        }
        
        /* Style for the suit group container (Horizontal card row) */
        .suit-group {
            display: flex;
            flex-direction: row; 
            flex-wrap: nowrap;
            gap: 2px; 
            padding: 1px 0;
            border-radius: 3px;
        }

        #west .suit-group {
            justify-content: flex-end; 
        }
        
        #east .suit-group {
            justify-content: flex-start; 
        }
        
        #south {
            width: 100%;
        }

        .hand h2 {
            font-size: 1em; 
            margin-bottom: 5px;
            color: #f9f9f9;
        }

        /* Cards in hand (for horizontal display on South) */
        #south .cards {
            flex-direction: row; 
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            align-items: flex-start;
        }

        .cards {
            display: flex;
            flex-grow: 1;
        }

        /* Card Styling */
        .card {
            width: 25px; 
            height: 30px; 
            padding: 0;
            background: #fff;
            color: black;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.6rem; 
            line-height: 35px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s, border 0.2s;
            position: relative;
            user-select: none;
            cursor: default;
        }
        
        .card span {
            display: block;
            line-height: normal;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .card.red { color: darkred; }
        .card.black { color: black; }

        /* Highlighting playable cards */
        .card.playable {
            cursor: pointer;
        }
        
        /* Hover effect for side hands (West/East) shifts vertically */
        #west .card.playable:hover, #east .card.playable:hover {
            transform: translateY(-2px) scale(1.05); 
        }

        /* Hover effect for horizontal hand (South) shifts vertically */
        #south .card.playable:hover {
            transform: translateY(-4px) scale(1.05);
        }
        
        .card.disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3) !important;
            border: 1px solid #ccc;
        }
        
        /* Board/Table Styling (Central Placement) */
        #board {
            padding: 10px; 
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            width: 35%; 
            min-height: 150px; 
            margin: 0 3px; 
            border: 2px solid #ffeb3b;
            box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
        }
        
        #board h2 {
            font-size: 1.2em;
            margin-bottom: 8px;
            color: #ffeb3b;
        }

        #trick {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 5px; 
            min-height: 45px;
            color: #fff;
            flex-wrap: wrap; 
        }
        
        #trick .card {
            width: 30px !important; 
            height: 45px !important; 
            line-height: 45px !important;
            font-size: 0.8em !important;
        }
        
        #trick > div {
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Status and Score */
        #status {
            margin-top: 15px;
            font-size: 1.3em;
            font-weight: bold;
            color: #f9f9f9;
        }

        #score {
            margin-top: 5px;
            font-size: 1em;
            color: #ffeb3b;
            margin-bottom: 15px;
        }

        /* Current player highlight */
        .current-player {
            border-color: green !important;
        }

        /* MODIFIED MEDIA QUERY - Keeps horizontal layout */
        @media (max-width: 600px) {
            .middle-section {
                flex-wrap: nowrap;
                justify-content: space-around;
                align-items: flex-start;
            }

            #west, #east {
                min-width: 80px; 
                max-width: 30%; 
                min-height: 130px;
            }

            #board {
                width: 40%; 
                margin: 0 2px;
                min-height: 130px;
                margin-top: 15px; 
            }
            
            #south .cards {
                gap: 2px; 
            }

             .card {
                width: 22px; 
                height: 28px; 
                font-size: 0.55rem; 
            }
        }
    </style>
</head>
<body>
    <h1>♠️ South – მიზერი ♦️</h1>
    <p> თამაშს იწყებს - East</p>

    <div id="game">
        <div class="middle-section">
            
            <div class="hand" id="west">
                <h2>West (თქვენი სვლა)</h2>
                <div class="cards" id="west-cards"></div>
            </div>

            <div id="board">
                <h2>Board</h2>
                <div id="trick">არცერთი კარტი არ დევს</div>
            </div>

            <div class="hand" id="east">
                <h2>East (თქვენი სვლა)</h2>
                <div class="cards" id="east-cards"></div>
            </div>
        </div>

        <div class="hand" id="south">
            <h2>South (AI)</h2>
            <div class="cards" id="south-cards"></div>
        </div>
    </div>

    <div id="status">თამაში დაიწყო!</div>
    <div id="score">South-ის წაღებული დარიგება: 0</div>

    <script>
        let west = ["Q♠","K♦","Q♦","J♦","10♦","K♣","Q♣","J♥","10♥","9♥"];
        let east = ["A♠","K♠","J♠","10♠","A♦","7♦","A♣","10♣","A♥","7♥"];
        let south = ["9♠","8♠","7♠","9♦","8♦","J♣","9♣","8♣","7♣","8♥"];

        let board = [];
        let southTricks = 0;
        let turn = "east";

        // Helper function to get suit order for sorting
        function getSuitOrder(card) {
            const s = suit(card);
            switch (s) {
                case "♠": return 1;
                case "♥": return 2;
                case "♦": return 3;
                case "♣": return 4;
                default: return 5;
            }
        }

        // Helper function to get card rank
        function rank(card) {
            let order = {"7":1,"8":2,"9":3,"10":4,"J":5,"Q":6,"K":7,"A":8}; 
            const rankKey = card.replace(/[^0-9JQKA]/g,""); 
            return order[rankKey];
        }

        // Helper function to get card suit
        function suit(card) {
            return card.slice(-1);
        }

        // Helper function to sort cards by rank within the hand
        function sortHand(hand) {
            return hand.sort((a, b) => {
                const suitOrderA = getSuitOrder(a);
                const suitOrderB = getSuitOrder(b);

                if (suitOrderA !== suitOrderB) {
                    return suitOrderA - suitOrderB;
                }
                return rank(b) - rank(a); // Descending rank within suit
            });
        }
        
        function renderHands() {
            render("west-cards", sortHand(west), "west");
            render("east-cards", sortHand(east), "east");
            render("south-cards", sortHand(south), "south"); 
            updatePlayerHighlight();
        }
        
        function render(id, hand, who) {
            let div = document.getElementById(id);
            div.innerHTML = "";
            
            // Group cards by suit
            const suitGroups = hand.reduce((groups, card) => {
                const s = suit(card);
                if (!groups[s]) {
                    groups[s] = [];
                }
                groups[s].push(card);
                return groups;
            }, {});
            
            // Determine suit order for display
            const orderedSuits = ["♠", "♥", "♦", "♣"].filter(s => suitGroups[s] && suitGroups[s].length > 0);
            
            if (who === "south") {
                 // For South (horizontal layout)
                 const allCards = orderedSuits.flatMap(s => suitGroups[s]);
                 allCards.forEach((c) => {
                    const cardElement = createCardElement(c, who);
                    div.appendChild(cardElement);
                });
            } else {
                 // For West/East (vertical suit groups)
                orderedSuits.forEach(s => {
                    const groupDiv = document.createElement("div");
                    groupDiv.className = "suit-group";
                    
                    suitGroups[s].forEach((c) => {
                        const cardElement = createCardElement(c, who);
                        groupDiv.appendChild(cardElement);
                    });
                    
                    div.appendChild(groupDiv);
                });
            }
        }
        
        function createCardElement(c, who) {
            let span = document.createElement("div");
            
            const s = suit(c);
            const rankValue = c.slice(0, -1);
            span.innerHTML = `<span>${rankValue}${s}</span>`; 
            span.className = "card" + (s==="♥"||s==="♦" ? " red":" black");

            // Enable clicking for player-controlled hands (West and East) only if it's their turn
            if (who==="west" || who==="east") {
                if (isCardAllowed(who, c)) {
                    span.classList.add("playable");
                    span.onclick = ()=> playCardByValue(who, c); 
                } else if (who===turn) {
                    span.classList.add("disabled");
                }
            }
            
            if (who === "south") {
                span.classList.remove("disabled");
                span.onclick = null;
            }
            return span;
        }

        function updatePlayerHighlight() {
            document.getElementById("west").classList.remove("current-player");
            document.getElementById("east").classList.remove("current-player");
            document.getElementById("south").classList.remove("current-player");
            
            if (turn === "west" || turn === "east" || turn === "south") {
                document.getElementById(turn).classList.add("current-player");
            }
        }

        function isCardAllowed(player, card) {
            if (player !== turn) return false;
            if (board.length === 0) {
                return true;
            }
            
            const leadSuit = suit(board[0].card);
            const cardSuit = suit(card);
            
            if (cardSuit === leadSuit) {
                return true;
            }
            
            const playerHand = player === "west" ? west : east;
            const hasLeadSuit = playerHand.some(c => suit(c) === leadSuit);
            
            return !hasLeadSuit;
        }

        function playCardByValue(who, cardValue) {
            let card;
            let hand;
            
            if (who==="west") {
                hand = west;
            } else if (who==="east") {
                hand = east;
            } else {
                return; 
            }
            
            const index = hand.indexOf(cardValue);
            if (index > -1) {
                card = hand.splice(index,1)[0];
            } else {
                return;
            }
            
            if (card) {
                board.push({player:who,card});
                updateBoard();
                nextTurn();
            }
        }

        // Helper: Get suits present in a hand
        function getHandSuitCounts(hand) {
            const suitCounts = {};
            hand.forEach(c => {
                const s = suit(c);
                if (!suitCounts[s]) suitCounts[s] = [];
                suitCounts[s].push(c);
            });
            return suitCounts;
        }

        // Helper: Check if West or East has a card higher than given card in the card's suit
        function opponentHasHigher(card) {
            const currentSuit = suit(card);
            const cardRank = rank(card);
            
            const westSuit = west.filter(c => suit(c) === currentSuit);
            const eastSuit = east.filter(c => suit(c) === currentSuit);

            const allOpponentCards = [...westSuit, ...eastSuit];
            
            // Check if any opponent card in that suit is strictly higher
            return allOpponentCards.some(c => rank(c) > cardRank);
        }

        // Helper: Check if a card is a guaranteed winner in its suit based on all open hands
        function isGuaranteedWinner(card) {
            return !opponentHasHigher(card);
        }

        // ************ UNIVERSAL MISERE AI WITH DEEP ANALYSIS ************
        
        // Simulate what happens if South plays a specific card
        function simulateCardPlay(card, currentBoard, currentSouth, currentWest, currentEast) {
            const cardSuit = suit(card);
            const cardRank = rank(card);
            
            // If this is a lead
            if (currentBoard.length === 0) {
                return analyzeLeadCard(card, currentSouth, currentWest, currentEast);
            }
            
            // If following a trick
            const leadSuit = suit(currentBoard[0].card);
            
            if (cardSuit === leadSuit) {
                // Following suit
                return analyzeFollowCard(card, currentBoard, currentSouth, currentWest, currentEast);
            } else {
                // Discarding (void in lead suit)
                return analyzeDiscardCard(card, currentSouth, currentWest, currentEast);
            }
        }
        
        // Analyze leading a card
        function analyzeLeadCard(card, currentSouth, currentWest, currentEast) {
            const cardSuit = suit(card);
            const cardRank = rank(card);
            let dangerScore = 0;
            
            const southSuits = getHandSuitCounts(currentSouth);
            const suitLength = (southSuits[cardSuit] || []).length;
            
            // 1. Guaranteed winner is VERY bad
            if (isGuaranteedWinner(card)) {
                dangerScore += 1000;
            }
            
            // 2. Check opponents' holdings
            const westSuitCards = currentWest.filter(c => suit(c) === cardSuit);
            const eastSuitCards = currentEast.filter(c => suit(c) === cardSuit);
            
            // 3. Prefer long suits (more escape cards)
            dangerScore -= suitLength * 20;
            
            // 4. Higher cards are more dangerous
            dangerScore += cardRank * 15;
            
            // 5. If opponent is void, very dangerous
            if (westSuitCards.length === 0 || eastSuitCards.length === 0) {
                dangerScore += 200;
            }
            
            // 6. Middle cards from long suits are good bait
            if (suitLength >= 3 && cardRank >= 2 && cardRank <= 4) {
                dangerScore -= 40;
            }
            
            return dangerScore;
        }
        
        // Analyze following a card
        function analyzeFollowCard(card, currentBoard, currentSouth, currentWest, currentEast) {
            const leadSuit = suit(currentBoard[0].card);
            const cardRank = rank(card);
            let dangerScore = 0;
            
            const currentHighest = getHighestCardInTrickFromBoard(currentBoard);
            const currentHighestRank = rank(currentHighest);
            
            const southSuits = getHandSuitCounts(currentSouth);
            const sameSuitCards = southSuits[leadSuit] || [];
            
            // Determine position
            const isSecondPosition = currentBoard.length === 1;
            const isThirdPosition = currentBoard.length === 2;
            
            if (cardRank < currentHighestRank) {
                // Safe card (won't win)
                
                if (isSecondPosition) {
                    // Second position: play higher safe card to force third player
                    const safenessBonus = cardRank * 5; // Higher safe cards get bonus
                    dangerScore -= safenessBonus;
                } else {
                    // Third position: trick is decided, play high safe card
                    dangerScore -= cardRank * 3;
                }
                
            } else {
                // Dangerous card (will win or equals highest)
                
                if (isSecondPosition) {
                    // CRITICAL: Check if third player can overtake us
                    const firstPlayer = currentBoard[0].player;
                    const thirdPlayer = firstPlayer === "west" ? "east" : "west";
                    const thirdPlayerHand = thirdPlayer === "west" ? currentWest : currentEast;
                    const thirdPlayerSuit = thirdPlayerHand.filter(c => suit(c) === leadSuit);
                    
                    const canOvertake = thirdPlayerSuit.some(c => rank(c) > cardRank);
                    
                    if (canOvertake) {
                        // Third player can save us - play minimal winner
                        const minimality = (8 - cardRank) * 30; // Lower cards better
                        dangerScore -= minimality;
                        
                        // But check: will third player WANT to overtake?
                        // In misere, players want to AVOID winning
                        // So third player will overtake if they have higher cards
                        const maxThirdPlayerCard = Math.max(...thirdPlayerSuit.map(c => rank(c)));
                        if (maxThirdPlayerCard > cardRank + 1) {
                            // Third player has much higher cards, will likely overtake
                            dangerScore -= 50;
                        }
                    } else {
                        // We will definitely win - very bad
                        dangerScore += 500;
                        dangerScore += cardRank * 20; // Higher winners even worse
                    }
                    
                } else {
                    // Third position: we will win the trick
                    dangerScore += 400;
                    dangerScore += cardRank * 15;
                }
            }
            
            // Check if this leaves us in a bad position in this suit
            const remainingInSuit = sameSuitCards.filter(c => c !== card);
            if (remainingInSuit.length > 0) {
                const lowestRemaining = Math.min(...remainingInSuit.map(c => rank(c)));
                
                // Check if we'll be forced to win later with remaining cards
                const westSuitCards = currentWest.filter(c => suit(c) === leadSuit);
                const eastSuitCards = currentEast.filter(c => suit(c) === leadSuit);
                const allOpponentCards = [...westSuitCards, ...eastSuitCards];
                
                if (allOpponentCards.length > 0) {
                    const maxOpponent = Math.max(...allOpponentCards.map(c => rank(c)));
                    
                    if (lowestRemaining > maxOpponent) {
                        // We'll be forced to win later!
                        dangerScore += 200;
                    }
                }
            }
            
            return dangerScore;
        }
        
        // Analyze discarding a card (void in lead suit)
        function analyzeDiscardCard(card, currentSouth, currentWest, currentEast) {
            const cardSuit = suit(card);
            const cardRank = rank(card);
            let dangerScore = 0;
            
            const southSuits = getHandSuitCounts(currentSouth);
            const suitLength = (southSuits[cardSuit] || []).length;
            
            // 1. Guaranteed winners MUST go first (highest priority)
            if (isGuaranteedWinner(card)) {
                return -10000 - (cardRank * 100); // Extremely negative = good to discard
            }
            
            // 2. Analyze suit vulnerability (CRITICAL FOR SQUEEZE SITUATIONS)
            const westSuitCards = currentWest.filter(c => suit(c) === cardSuit);
            const eastSuitCards = currentEast.filter(c => suit(c) === cardSuit);
            const southSuitCards = southSuits[cardSuit] || [];
            
            const opponentsWithSuit = (westSuitCards.length > 0 ? 1 : 0) + (eastSuitCards.length > 0 ? 1 : 0);
            
            // 3. SINGLETON - always great to discard (except if it's our only exit card)
            if (suitLength === 1) {
                // Check if other suits are safe
                let hasOtherSafeSuits = false;
                for (const s in southSuits) {
                    if (s !== cardSuit && southSuits[s].length >= 2) {
                        hasOtherSafeSuits = true;
                        break;
                    }
                }
                
                if (hasOtherSafeSuits) {
                    return -5000 - (cardRank * 50); // Very good to discard
                } else {
                    return -2000 - (cardRank * 30); // Still good but less priority
                }
            }
            
            // 4. DOUBLETON - CRITICAL ANALYSIS
            if (suitLength === 2) {
                if (opponentsWithSuit === 2) {
                    // Both opponents have this suit - DANGER ZONE
                    
                    const allOpponentCards = [...westSuitCards, ...eastSuitCards];
                    const highestOpponent = Math.max(...allOpponentCards.map(c => rank(c)));
                    const ourLowest = Math.min(...southSuitCards.map(c => rank(c)));
                    const ourHighest = Math.max(...southSuitCards.map(c => rank(c)));
                    
                    if (ourLowest > highestOpponent) {
                        // TRAPPED! Both our cards will win
                        // We MUST start discarding from this suit NOW
                        if (cardRank === ourHighest) {
                            return -8000; // MUST discard the higher one
                        } else {
                            return +5000; // NEVER discard the lower one yet
                        }
                    } else {
                        // Not trapped yet, but dangerous
                        // Prefer to discard the higher card to be safe
                        if (cardRank === ourHighest) {
                            return -3000; // Good to discard higher card
                        } else {
                            return +2000; // Keep the lower card for now
                        }
                    }
                } else {
                    // Only 0-1 opponent has this suit - less dangerous
                    return -1000 - (cardRank * 20);
                }
            }
            
            // 5. LONG SUITS (3+) - need to keep for exit cards
            if (suitLength >= 3) {
                // Long suits are valuable - penalize discarding from them
                dangerScore += 2000;
                
                // But if it's a very high card (A, K, Q), still consider
                if (cardRank >= 6) {
                    dangerScore -= 800;
                }
                
                return dangerScore;
            }
            
            // 6. General preference: high cards are more dangerous
            dangerScore += cardRank * 50;
            
            return dangerScore;
        }
        
        // Helper for simulation
        function getHighestCardInTrickFromBoard(board) {
            const leadSuit = suit(board[0].card);
            let currentWinner = board[0];
            
            for (let i = 1; i < board.length; i++) {
                const currentCard = board[i];
                if (suit(currentCard.card) === leadSuit) {
                    if (rank(currentCard.card) > rank(currentWinner.card)) {
                        currentWinner = currentCard;
                    }
                }
            }
            return currentWinner.card;
        }

        function southMove() {
            let bestCard = null;
            let lowestDanger = Infinity;
            
            // First, filter only legal cards
            let legalCards = [];
            
            if (board.length === 0) {
                // Leading - all cards are legal
                legalCards = [...south];
            } else {
                // Following - must follow suit if possible
                const leadSuit = suit(board[0].card);
                const sameSuitCards = south.filter(c => suit(c) === leadSuit);
                
                if (sameSuitCards.length > 0) {
                    // Must follow suit
                    legalCards = sameSuitCards;
                } else {
                    // Void in lead suit - can discard any card
                    legalCards = [...south];
                }
            }
            
            // Evaluate every legal card
            for (const card of legalCards) {
                const danger = simulateCardPlay(card, board, south, west, east);
                
                if (danger < lowestDanger) {
                    lowestDanger = danger;
                    bestCard = card;
                }
            }
            
            // Play the chosen card
            if (bestCard) {
                south = south.filter(c => c !== bestCard);
                board.push({player: "south", card: bestCard});
                updateBoard();
                nextTurn();
            }
        }

        function getHighestCardInTrick() {
            const leadSuit = suit(board[0].card);
            let currentWinner = board[0];
            
            for (let i = 1; i < board.length; i++) {
                const currentCard = board[i];
                if (suit(currentCard.card) === leadSuit) {
                    if (rank(currentCard.card) > rank(currentWinner.card)) {
                        currentWinner = currentCard;
                    }
                }
            }
            return currentWinner.card;
        }

        function nextTurn() {
            if (board.length===3) {
                setTimeout(finishTrick,1000); 
                return;
            }
            
            // Determine whose turn is next
            if (turn==="east") turn="south";
            else if (turn==="south") turn="west";
            else if (turn==="west") turn="east";
            
            if (turn==="south") {
                document.getElementById("status").textContent = "South-ის სვლაა...";
                setTimeout(southMove,800); 
            } else {
                // West/East are now controlled by the player (clicking on playable cards)
                document.getElementById("status").textContent = (turn==="east" ? "East" : "West") + "-ის სვლაა! აირჩიეთ კარტი.";
            }
            renderHands();
        }

        function finishTrick() {
            let winner = winnerOfTrick(board);
            document.getElementById("status").textContent = "ტური მოიგო: "+winner;
            
            if (winner==="south") southTricks++; 
            document.getElementById("score").textContent = "South-ის წაღებული დარიგება: " + southTricks;
            
            board=[];
            updateBoard();

            if (west.length===0) {
                endGame();
            } else {
                turn=winner; 
                if (turn==="south") {
                    document.getElementById("status").textContent = "South-ის სვლაა...";
                    setTimeout(southMove,800); 
                } else {
                    document.getElementById("status").textContent = (turn==="east" ? "East" : "West") + "-ის სვლაა! აირჩიეთ კარტი.";
                }
                renderHands();
            }
        }

        function updateBoard() {
            document.getElementById("trick").innerHTML = board.map(b=>{
                const s = suit(b.card);
                const rankValue = b.card.slice(0, -1);
                const colorClass = (s==="♥"||s==="♦" ? " red":" black");
                return `
                    <div>
                        ${b.player}: 
                        <div class='card ${colorClass}'>
                            <span>${rankValue}${s}</span>
                        </div>
                    </div>
                `;
            }).join(" ") || "არცერთი კარტი არ დევს";
            renderHands();
        }

        function winnerOfTrick(trick) {
            let leadSuit = suit(trick[0].card);
            let valid = trick.filter(t=>suit(t.card)===leadSuit); 
            
            if (valid.length === 0) {
                 return trick[0].player;
            }

            let winner = valid.reduce((a,b)=>rank(a.card)>rank(b.card)?a:b); 
            return winner.player;
        }

        function endGame() {
            if (southTricks===0) {
                document.getElementById("status").textContent = "AI-მ (South) მოიგო! **მიზერი შესრულდა** ✅";
                document.getElementById("status").style.color = "#00f000";
            } else {
                document.getElementById("status").textContent = "მოთამაშემ მოიგო! AI აიღო **"+southTricks+" დარიგება** ❌";
                document.getElementById("status").style.color = "red";
            }
        }

        renderHands();
    </script>
</body>
</html>
