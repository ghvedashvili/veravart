
<!doctype html>
<html lang="ka">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blokus — 2 Players (You vs kidsmart)</title>
<style>
  :root{
    --panel-bg: #fff;
    --board-bg: #f5f7fb;
    --cell: #eef6ff;
    --player1: #ffe9d6;
    --player2: #dff0ff;
    --highlight: #c9f7d0;
    --anchor-highlight: #4ade80; /* უფრო ღრმა მწვანე საფუძვლისთვის */
    --muted: #6b7280;
  }
  *{box-sizing:border-box}
  body{font-family:system-ui,Arial,Helvetica,sans-serif;margin:12px;background:linear-gradient(#fbfdff,#fff);color:#111}
  h1{font-size:18px;margin:6px 0 12px 0}
  .wrap{display:flex;gap:14px;align-items:flex-start;flex-wrap:wrap}
  /* Left: board */
  .left{flex:1;min-width:220px;max-width:680px}
  .panel{background:var(--panel-bg);padding:10px;border-radius:10px;box-shadow:0 6px 20px rgba(9,30,66,0.06)}
  .board-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .muted{color:var(--muted);font-size:13px}
  /* responsive grid: square board that fits container */
  .grid-wrap{display:flex;justify-content:center}
  .grid{
    display:grid;
    grid-template-columns: repeat(7, 1fr); /* 7x7 დაფა */
    grid-auto-rows: 1fr;
    gap:6px;
    width: min(540px, 86vw);
    aspect-ratio: 1 / 1;
    background:var(--board-bg);
    padding:6px;
    border-radius:10px;
  }
  .cell{
    background:var(--cell);
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    color:#555;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
    cursor:pointer;
  }
  .cell.edge{ box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); }
  .cell.player1{ background:var(--player1); }
  .cell.player2{ background:var(--player2); }
  .cell.highlight{ background:var(--highlight) !important; box-shadow: 0 0 0 2px rgba(0,0,0,0.03) inset; }
  /* right: pieces */
  .right{width:320px;min-width:240px}
  .pieces{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;max-height:420px;overflow:auto;padding-bottom:6px}
  .piece{border-radius:8px;border:1px solid #eee;padding:6px;min-width:62px;display:inline-grid;place-items:center;cursor:pointer;background:#fff}
  .piece.used{opacity:.35;cursor:default}
  .piece.selected{outline:3px solid rgba(34,197,94,0.18)}
  .mini{display:grid;gap:2px}
  .mini .pcell{width:10px;height:10px;border-radius:2px;background:#111}
  .controls{display:flex;gap:8px;margin-top:8px}
  button{padding:7px 9px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
  button.secondary{background:#f8fafc}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  /* small screens tweaks */
  @media (max-width:520px){
    .right{width:100%}
    .wrap{flex-direction:column}
    .grid{gap:4px}
    .cell{border-radius:5px}
  }
  /* ახალი სტილები kidsmart-ის ფიგურებისთვის */
  .ai-pieces-info {
    margin-top: 10px;
    padding: 8px;
    background: #f8fafc;
    border-radius: 6px;
    font-size: 13px;
  }
  .ai-pieces-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
  }
  .ai-piece {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 6px;
    background: white;
    border-radius: 4px;
    border: 1px solid #e5e7eb;
    font-size: 12px;
  }
  /* ახალი სტილები შეტყობინებებისთვის */
  .message {
    margin-top: 10px;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    display: none;
  }
  .message.player-turn {
    background: #d1fae5;
    color: #065f46;
    display: block;
  }
  .message.no-moves {
    background: #fee2e2;
    color: #991b1b;
    display: block;
  }
  .message.game-over {
    background: #fef3c7;
    color: #92400e;
    display: block;
    text-align: center;
    font-weight: bold;
  }
  .restart-btn {
    margin-top: 10px;
    padding: 8px 16px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    display: none;
  }
  .restart-btn:hover {
    background: #2563eb;
  }
  /* საერთო ანგარიშის სტილები */
  .score-panel {
    background: #f8fafc;
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 10px;
    border: 1px solid #e5e7eb;
  }
  .score-title {
    font-weight: bold;
    margin-bottom: 8px;
    font-size: 14px;
  }
  .score-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
    font-size: 13px;
  }
  .score-total {
    text-align:center;
    font-weight: bold;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="panel">
        <!-- საერთო ანგარიში -->
        <div class="score-panel">
         
          
          <div class="score-total">
            <span>საერთო ანგარიში:</span><hr>
            <span id="totalResult">0 - 0</span>
          </div>
        </div>

        <div class="board-head">
          <div><strong>Board</strong> — 7 × 7</div>
          <div class="muted">Turn: <span id="turnLabel">Player</span></div>
        </div>

        <div class="grid-wrap">
          <div id="grid" class="grid" aria-hidden="false"></div>
        </div>

        <div style="margin-top:10px" class="muted">
          Player pieces left: <span id="pCount">0</span> — kidsmart pieces left: <span id="aiCount">0</span>
        </div>

        <!-- შეტყობინებები -->
        <div id="playerTurnMessage" class="message player-turn">თქვენი სვლაა - აირჩიეთ ფიგურა</div>
        <div id="noMovesMessage" class="message no-moves">სვლა არ გაქვთ - kidsmart თამაშობს</div>
        <div id="gameOverMessage" class="message game-over"></div>
        
        <button id="restartBtn" class="restart-btn">თამაშის ხელახლა დაწყება</button>

        <!-- ახალი სექცია kidsmart-ის ფიგურებისთვის -->
        <div class="ai-pieces-info">
          <div><strong>Kidsmart-ის დარჩენილი ფიგურები:</strong></div>
          <div id="aiPiecesList" class="ai-pieces-list"></div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div><strong>Selected piece</strong></div>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <div id="selectedPreview" class="piece" style="min-width:120px;min-height:58px">No piece</div>
          <div style="display:flex;gap:6px">
            <button id="rotateBtn">Rotate ⟳</button>
            <button id="flipBtn">Flip ↔</button>
            <button id="passBtn">Pass turn</button>
          </div>
        </div>

        <hr style="margin:10px 0">

        <div><strong>Your Pieces</strong> <span class="muted">(tap to select)</span></div>
        <div id="pieces" class="pieces"></div>

        <hr style="margin:10px 0">

        <div><strong>Instructions</strong></div>
        <div class="muted" style="margin-top:6px">
          აირჩიე ფიგურა — დაფაზე მაშინვე გამოჩნდება ყველა შესაძლო ადგილი, სადაც შეგიძლია დადება (მწვანე). დააჭირე მონიშნულ უჯრას და ფიგურა დაიდება. პირველი შენიანი ნაბიჯი უნდა შეეხოს ზედა-მარცხით კუთხეს. (მობილურზეც მუშაობს — tap only).
        </div>
      </div>
    </div>
  </div>

  <footer>Simple Blokus-like game — AI (kidsmart) uses improved strategy.</footer>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyD0z4y5Q7Q5Z3Q3Q3Q3Q3Q3Q3Q3Q3Q3Q",
  authDomain: "newspaperveravart-default-rtdb.firebaseapp.com",
  databaseURL: "https://newspaperveravart-default-rtdb.firebaseio.com",
  projectId: "newspaperveravart",
  storageBucket: "newspaperveravart.appspot.com",
  messagingSenderId: "1234567890",
  appId: "1:1234567890:web:1234567890abcdef"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

/*
  Single-file Blokus-like game (2 players: human vs kidsmart).
  - Click piece to select
  - After selection, all valid anchor positions for the *current transformed orientation* are highlighted
  - Click a highlighted cell to place
  - Rotate / Flip update preview & highlighted positions
  - AI moves automatically (improved strategy)
*/

// board size - 7x7 დაფა (პატარა, რომ ყველა ფიგურა ვერ ჩაეტენოს)
const ROWS = 7, COLS = 7;
const gridEl = document.getElementById('grid');
const piecesEl = document.getElementById('pieces');
const selectedPreview = document.getElementById('selectedPreview');
const turnLabel = document.getElementById('turnLabel');
const pCountEl = document.getElementById('pCount');
const aiCountEl = document.getElementById('aiCount');
const aiPiecesListEl = document.getElementById('aiPiecesList');
const playerTurnMessage = document.getElementById('playerTurnMessage');
const noMovesMessage = document.getElementById('noMovesMessage');
const gameOverMessage = document.getElementById('gameOverMessage');
const restartBtn = document.getElementById('restartBtn');

const totalResultEl = document.getElementById('totalResult');

let board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0)); // 0 empty, 1 player, 2 ai
let cells = [];

// Basic piece set (10 ფიგურა, მაგრამ დაფა პატარაა რომ ყველა ვერ ჩაეტენოს)
const BASE_PIECES = [
  {id:'1', name:'Dot', shape:[[0,0]]},
  {id:'2', name:'Domino', shape:[[0,0],[1,0]]},
  {id:'3', name:'L3', shape:[[0,0],[1,0],[0,1]]},
  {id:'4', name:'I3', shape:[[0,0],[1,0],[2,0]]},
  {id:'5', name:'Square', shape:[[0,0],[1,0],[0,1],[1,1]]},
  {id:'6', name:'T4', shape:[[0,1],[1,0],[1,1],[2,1]]},
  {id:'7', name:'L4', shape:[[0,0],[0,1],[0,2],[1,0]]},
  {id:'8', name:'Z4', shape:[[0,0],[1,0],[1,1],[2,1]]},
  {id:'10', name:'Plus', shape:[[1,0],[0,1],[1,1],[2,1],[1,2]]}
];

// give each player one copy set
function clonePiecesForPlayer(player){
  return BASE_PIECES.map(p=>({
    id: p.id+'-'+player,
    name: p.name,
    owner: player,
    used: false,
    shape: p.shape.map(s=>[s[0], s[1]])
  }));
}

let playerPieces, aiPieces;

// selection / transform state
let selected = null; // {pieceId, originalShape, owner}
let rotation = 0; // 0..3 (90deg steps)
let flipped = false; // horizontal mirror

// turn and pass flags
let turn = 1; // 1 player, 2 ai
let passed = {1:false, 2:false};
let gameOver = false;

// საერთო ანგარიში
let totalScores = { player: 0, ai: 0 };

// starting corners: player top-left, ai bottom-right (col,row)
const startCorners = {1: [0,0], 2: [COLS-1, ROWS-1]};

// draw grid (responsive squares)
function drawGrid(){
  gridEl.innerHTML = '';
  cells = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d = document.createElement('div');
      d.className = 'cell';
      // subtle edge marker
      if(r===0||c===0||r===ROWS-1||c===COLS-1) d.classList.add('edge');
      d.dataset.r = r; d.dataset.c = c;
      d.addEventListener('click', ()=>onCellClick(r,c));
      gridEl.appendChild(d);
      cells.push(d);
    }
  }
  refreshBoardView();
}

// render board colors
function refreshBoardView(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const el = cells[idx];
      el.classList.remove('player1','player2','highlight','piece-part','anchor-part');
      el.style.background = ''; // Reset any custom background
      
      if(board[r][c]===1) el.classList.add('player1');
      if(board[r][c]===2) el.classList.add('player2');
    }
  }
  
  // if a piece selected, show highlights for current transformed orientation
  if(turn===1 && selected){
    highlightValidMoves();
  }
}


// transforms for shapes
function rotateShape(shape){ // 90deg clockwise
  return shape.map(([x,y])=>[y, -x]);
}
function flipShape(shape){ // mirror horizontally
  return shape.map(([x,y])=>[-x, y]);
}
function normalize(shape){
  const xs = shape.map(s=>s[0]), ys = shape.map(s=>s[1]);
  const minx = Math.min(...xs), miny = Math.min(...ys);
  return shape.map(([x,y])=>[x-minx, y-miny]);
}
function canonicalVariants(shape){
  // all rotations+flips (deduped)
  const variants = [];
  let s = shape.map(a=>[a[0],a[1]]);
  for(let i=0;i<4;i++){
    s = rotateShape(s);
    variants.push(normalize(s.map(a=>[a[0],a[1]])));
    variants.push(normalize(flipShape(s.map(a=>[a[0],a[1]]))));
  }
  // dedupe
  const set = new Set();
  const out = [];
  for(const v of variants){
    const key = JSON.stringify(v.slice().sort((a,b)=>a[0]-b[0]||a[1]-b[1]));
    if(!set.has(key)){ set.add(key); out.push(v); }
  }
  return out;
}

// check placement validity by Blokus-like rules:
// - shape in bounds
// - no overlap
// - cannot touch same-owner along edge
// - must touch same-owner at corner at least once (except first move must cover start corner)
function canPlaceAt(owner, shape, baseR, baseC){
  // owner pieces used?
  const ownerArr = owner===1 ? playerPieces : aiPieces;
  const madeAny = ownerArr.some(p=>p.used);
  const isFirstMove = !madeAny; // true if player hasn't placed any piece yet

  let touchesCorner = false;
  for(const [x,y] of shape){
    const r = baseR + y, c = baseC + x;
    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return false; // out of bounds
    if(board[r][c] !== 0) return false; // overlap
    // edge adjacency
    const edges = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [ex,ey] of edges){
      const nr = r + ey, nc = c + ex;
      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS){
        if(board[nr][nc] === owner) return false; // touches same owner by edge -> invalid
      }
    }
    // corner adjacency
    const corners = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [cx,cy] of corners){
      const nr = r + cy, nc = c + cx;
      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS){
        if(board[nr][nc] === owner) touchesCorner = true;
      }
    }
  }

  if(isFirstMove){
    // require shape to include owner's start corner cell
    const [sc, sr] = startCorners[owner]; // [col, row]
    let coversStart = false;
    for(const [x,y] of shape){
      if(baseR + y === sr && baseC + x === sc) coversStart = true;
    }
    return coversStart;
  }
  return touchesCorner;
}

// place piece onto board and mark used
function placePiece(owner, pieceId, shape, baseR, baseC){
  for(const [x,y] of shape){
    board[baseR + y][baseC + x] = owner;
  }
  const arr = owner===1 ? playerPieces : aiPieces;
  const p = arr.find(pp => pp.id === pieceId);
  if(p) p.used = true;
  
  // განახლება kidsmart-ის ფიგურების ჩვენების
  updateAiPiecesDisplay();
  // განახლება მოთამაშის ფიგურების ჩვენების
  renderPieces();
}

// render player's pieces (right panel)
function renderPieces(){
  piecesEl.innerHTML = '';
  playerPieces.forEach(p=>{
    const b = document.createElement('div');
    b.className = 'piece' + (p.used ? ' used' : '');
    b.dataset.pieceId = p.id;
    // preview mini-grid
    const norm = normalize(p.shape);
    const w = Math.max(...norm.map(s=>s[0]))+1, h = Math.max(...norm.map(s=>s[1]))+1;
    const mini = document.createElement('div'); mini.className='mini';
    mini.style.gridTemplateColumns = `repeat(${w}, 10px)`;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const pc = document.createElement('div'); pc.className='pcell';
        if(norm.some(a=>a[0]===x && a[1]===y)) pc.style.opacity = '0.95'; else pc.style.opacity = '0.06';
        mini.appendChild(pc);
      }
    }
    b.appendChild(mini);
    // click handler
    b.addEventListener('click', ()=>{
      if(p.used || turn !== 1 || gameOver) return;
      selectPiece(p);
      // update selected class visuals
      Array.from(piecesEl.children).forEach(ch => ch.classList.remove('selected'));
      b.classList.add('selected');
    });
    piecesEl.appendChild(b);
  });
}

// ახალი ფუნქცია kidsmart-ის ფიგურების ჩვენებისთვის
function updateAiPiecesDisplay(){
  aiPiecesListEl.innerHTML = '';
  const unusedAiPieces = aiPieces.filter(p => !p.used);
  
  if (unusedAiPieces.length === 0) {
    aiPiecesListEl.innerHTML = '<span style="color: var(--muted)">ყველა ფიგურა გამოყენებულია</span>';
    return;
  }
  
  unusedAiPieces.forEach(p => {
    const pieceEl = document.createElement('div');
    pieceEl.className = 'ai-piece';
    
    // მინი პრევიუ
    const norm = normalize(p.shape);
    const preview = document.createElement('div');
    preview.style.display = 'flex';
    preview.style.flexDirection = 'column';
    preview.style.gap = '1px';
    
    const maxX = Math.max(...norm.map(s => s[0]));
    const maxY = Math.max(...norm.map(s => s[1]));
    
    for (let y = 0; y <= maxY; y++) {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.gap = '1px';
      
      for (let x = 0; x <= maxX; x++) {
        const cell = document.createElement('div');
        cell.style.width = '6px';
        cell.style.height = '6px';
        cell.style.borderRadius = '1px';
        cell.style.backgroundColor = '#3b82f6';
        cell.style.opacity = norm.some(a => a[0] === x && a[1] === y) ? '1' : '0.2';
        row.appendChild(cell);
      }
      preview.appendChild(row);
    }
    
    pieceEl.appendChild(preview);
    
    const nameSpan = document.createElement('span');
    nameSpan.textContent = p.name;
    pieceEl.appendChild(nameSpan);
    
    aiPiecesListEl.appendChild(pieceEl);
  });
}

// select piece (store original shape but do not mutate)
function selectPiece(p){
  selected = { pieceId: p.id, originalShape: p.shape.map(s=>[s[0], s[1]]), owner: 1 };
  rotation = 0; flipped = false;
  updateSelectedPreview();
  refreshBoardView(); // will trigger highlight
}

// produce transformed (rotated & flipped) normalized shape for current selection
function getTransformedShape(){
  if(!selected) return null;
  let s = selected.originalShape.map(a=>[a[0], a[1]]);
  for(let i=0;i<rotation;i++) s = rotateShape(s);
  if(flipped) s = flipShape(s);
  s = normalize(s);
  return s;
}

// update the little preview box
function updateSelectedPreview(){
  selectedPreview.innerHTML = '';
  if(!selected){ selectedPreview.textContent = '(no piece)'; return; }
  const v = getTransformedShape();
  const w = Math.max(...v.map(s=>s[0]))+1, h = Math.max(...v.map(s=>s[1]))+1;
  const wrap = document.createElement('div'); wrap.style.display='grid'; wrap.style.gap='3px';
  wrap.style.gridTemplateColumns = `repeat(${w}, 14px)`;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const d = document.createElement('div');
      d.style.width='14px'; d.style.height='14px'; d.style.borderRadius='2px';
      if(v.some(a=>a[0]===x && a[1]===y)){ d.style.background='#111'; d.style.opacity='0.9'; }
      else { d.style.background='#111'; d.style.opacity='0.06'; }
      wrap.appendChild(d);
    }
  }
  selectedPreview.appendChild(wrap);
}

// highlight all valid anchor positions for current transformed orientation
function highlightValidMoves(){
  // clear existing
  cells.forEach(c => {
    c.classList.remove('highlight', 'piece-part', 'anchor-part');
    c.style.background = ''; // Reset any custom background
  });
  
  if(!selected) return;
  const shape = getTransformedShape();
  
  // Find the actual anchor point that is part of the piece
  // (the leftmost-topmost cell that is part of the piece)
  let anchorX = Infinity, anchorY = Infinity;
  for(const [x,y] of shape){
    if(y < anchorY || (y === anchorY && x < anchorX)) {
      anchorY = y;
      anchorX = x;
    }
  }
  
  // For each valid placement, mark ALL cells that the piece would occupy
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(canPlaceAt(1, shape, r, c)){
        // Calculate where the actual anchor would be placed on the board
        const anchorR = r + anchorY;
        const anchorC = c + anchorX;
        
        // Mark all cells that will be occupied by this piece
        for(const [x,y] of shape){
          const pieceR = r + y;
          const pieceC = c + x;
          if(pieceR >= 0 && pieceR < ROWS && pieceC >= 0 && pieceC < COLS){
            const idx = pieceR*COLS + pieceC;
            // The anchor cell (leftmost-topmost part of the piece) gets special color
            if(pieceR === anchorR && pieceC === anchorC) {
              cells[idx].classList.add('anchor-part');
              cells[idx].style.background = 'var(--anchor-highlight)';
            } else {
              cells[idx].classList.add('piece-part');
              cells[idx].style.background = 'var(--highlight)';
            }
          }
        }
      }
    }
  }
}

// clicking a cell (attempt to place if valid for current orientation)
function onCellClick(r,c){
  if (gameOver) return;
  
  // if player's turn & piece selected -> attempt to place
  if(turn === 1 && selected){
    const shape = getTransformedShape();
    
    // Find the actual anchor point that is part of the piece
    let anchorX = Infinity, anchorY = Infinity;
    for(const [x,y] of shape){
      if(y < anchorY || (y === anchorY && x < anchorX)) {
        anchorY = y;
        anchorX = x;
      }
    }
    
    // Calculate the base position from the clicked anchor position
    const baseR = r - anchorY;
    const baseC = c - anchorX;
    
    // Check if placement is valid at the calculated base position
    if(baseR >= 0 && baseR < ROWS && baseC >= 0 && baseC < COLS && 
       canPlaceAt(1, shape, baseR, baseC)) {
      
      placePiece(1, selected.pieceId, shape, baseR, baseC);
      // clear selection visually & logically
      selected = null;
      Array.from(piecesEl.children).forEach(ch=>ch.classList.remove('selected'));
      updateSelectedPreview();
      updateCounts();
      refreshBoardView();
      passed[1] = false;
      // next
      nextTurn();
      return;
    }
  }
  // if it's AI turn or no selection, nothing to do on click
}

// check if player has any valid moves
function playerHasValidMoves() {
  const available = playerPieces.filter(p => !p.used);
  for(const p of available){
    const variants = canonicalVariants(p.shape);
    for(const v of variants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(1, v, r, c)){
            return true;
          }
        }
      }
    }
  }
  return false;
}

// check if AI has any valid moves
function aiHasValidMoves() {
  const available = aiPieces.filter(p => !p.used);
  for(const p of available){
    const variants = canonicalVariants(p.shape);
    for(const v of variants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(2, v, r, c)){
            return true;
          }
        }
      }
    }
  }
  return false;
}

// update messages based on game state
function updateMessages() {
  if (gameOver) {
    playerTurnMessage.style.display = 'none';
    noMovesMessage.style.display = 'none';
    return;
  }
  
  if (turn === 1) {
    if (playerHasValidMoves()) {
      playerTurnMessage.style.display = 'block';
      noMovesMessage.style.display = 'none';
    } else {
      playerTurnMessage.style.display = 'none';
      noMovesMessage.style.display = 'block';
      // ავტომატურად გადავიდეთ AI-ის სვლაზე
      setTimeout(() => {
        if (!gameOver) {
          nextTurn();
        }
      }, 1500);
    }
  } else {
    playerTurnMessage.style.display = 'none';
    noMovesMessage.style.display = 'none';
  }
}

// nextTurn handler
function nextTurn(){
  if (gameOver) return;
  
  // შეამოწმეთ თუ მოთამაშეს არ აქვს სვლა
  if (turn === 1 && !playerHasValidMoves()) {
    passed[1] = true;
  }
  
  // შეამოწმეთ თუ AI-ს არ აქვს სვლა
  if (turn === 2 && !aiHasValidMoves()) {
    passed[2] = true;
  }
  
  turn = (turn === 1) ? 2 : 1;
  turnLabel.textContent = (turn === 1) ? 'Player' : 'kidsmart (AI)';
  
  updateMessages();
  
  // small delay so UI updates feel natural
  if(turn === 2){
    setTimeout(()=> aiMove(), 300);
  } else {
    refreshBoardView(); // ensure highlights appear for new selection if any
  }
  checkEnd();
}

// update pieces counts on UI
function updateCounts(){
  pCountEl.textContent = playerPieces.filter(p=>!p.used).length;
  aiCountEl.textContent = aiPieces.filter(p=>!p.used).length;
}

// გაუმჯობესებული AI ლოგიკა
function aiMove(){
  if (gameOver) return;
  
  // ჯერ ვცადოთ ყველა ფიგურა და ვიპოვოთ საუკეთესო სვლა
  const available = aiPieces.filter(p=>!p.used);
  let bestMove = null;
  let bestScore = -Infinity;
  
  for(const p of available){
    const variants = canonicalVariants(p.shape);
    for(const v of variants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(2, v, r, c)){
            // გამოვთვალოთ სვლის ხარისხი
            const score = evaluateMove(2, v, r, c);
            if(score > bestScore){
              bestScore = score;
              bestMove = {piece: p, shape: v, r, c};
            }
          }
        }
      }
    }
  }
  
  if(bestMove){
    placePiece(2, bestMove.piece.id, bestMove.shape, bestMove.r, bestMove.c);
    updateCounts();
    refreshBoardView();
    passed[2] = false;
    nextTurn();
  } else {
    // no move found -> pass
    passed[2] = true;
    nextTurn();
  }
}

// სვლის შეფასების ფუნქცია
function evaluateMove(owner, shape, baseR, baseC) {
  let score = 0;
  
  // 1. ფიგურის ზომა (უპირატესობა დიდ ფიგურებს)
  score += shape.length * 10;
  
  // 2. დაფის ცენტრში უფრო ახლოს მდებარეობა
  const centerR = Math.floor(ROWS / 2);
  const centerC = Math.floor(COLS / 2);
  let avgR = 0, avgC = 0;
  
  for(const [x,y] of shape){
    avgR += baseR + y;
    avgC += baseC + x;
  }
  avgR /= shape.length;
  avgC /= shape.length;
  
  const distFromCenter = Math.sqrt(
    Math.pow(avgR - centerR, 2) + Math.pow(avgC - centerC, 2)
  );
  score -= distFromCenter * 2;
  
  // 3. მოწინააღმდეგის ტერიტორიის ახლოს მდებარეობა
  let opponentProximity = 0;
  const opponent = owner === 1 ? 2 : 1;
  
  for(const [x,y] of shape){
    const r = baseR + y, c = baseC + x;
    // შევამოწმოთ მეზობელი უჯრები
    for(let dr = -2; dr <= 2; dr++){
      for(let dc = -2; dc <= 2; dc++){
        const nr = r + dr, nc = c + dc;
        if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS){
          if(board[nr][nc] === opponent){
            opponentProximity += 1 / (Math.abs(dr) + Math.abs(dc) + 1);
          }
        }
      }
    }
  }
  score += opponentProximity * 5;
  
  // 4. კუთხეების დაკავება
  let cornerScore = 0;
  const corners = [[0,0], [0,ROWS-1], [COLS-1,0], [COLS-1,ROWS-1]];
  for(const [cx,cy] of corners){
    for(const [x,y] of shape){
      if(baseC + x === cx && baseR + y === cy){
        cornerScore += 20;
      }
    }
  }
  score += cornerScore;
  
  return score;
}

// Firebase-ში ქულების შენახვა
async function saveScoreToFirebase(playerScore, aiScore) {
  try {
    const gameResult = {
      player: playerScore,
      ai: aiScore,
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      winner: playerScore > aiScore ? 'player' : playerScore < aiScore ? 'ai' : 'tie'
    };
    
    // შევინახოთ ახალი თამაში
    const newGameRef = database.ref('blokus/games').push();
    await newGameRef.set(gameResult);
    
    // განვაახლოთ საერთო ანგარიში
    const totalRef = database.ref('blokus/totals');
    const snapshot = await totalRef.once('value');
    const currentTotals = snapshot.val() || { player: 0, ai: 0 };
    
    if (playerScore > aiScore) {
      currentTotals.player += 1;
    } else if (aiScore > playerScore) {
      currentTotals.ai += 1;
    }
    
    await totalRef.set(currentTotals);
    
    // განვაახლოთ UI
    totalScores = currentTotals;
    updateTotalScoresDisplay();
    
    return true;
  } catch (error) {
    console.error('Error saving score to Firebase:', error);
    return false;
  }
}

// Firebase-დან ქულების წაკითხვა
async function loadScoresFromFirebase() {
  try {
    const totalRef = database.ref('blokus/totals');
    const snapshot = await totalRef.once('value');
    const totals = snapshot.val() || { player: 0, ai: 0 };
    
    totalScores = totals;
    updateTotalScoresDisplay();
    
    return true;
  } catch (error) {
    console.error('Error loading scores from Firebase:', error);
    return false;
  }
}

// საერთო ანგარიშის განახლება
function updateTotalScoresDisplay() {

  totalResultEl.textContent = `მოთამაშე ${totalScores.player} - ${totalScores.ai} kidsmart`;
}

// check end condition
async function checkEnd(){
  const bothPassed = passed[1] && passed[2];
  const noPieces = playerPieces.every(p=>p.used) && aiPieces.every(p=>p.used);
  
  if(bothPassed || noPieces){
    gameOver = true;
    let s1 = 0, s2 = 0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(board[r][c]===1) s1++;
        if(board[r][c]===2) s2++;
      }
    }
    
    let winnerText = '';
    if (s1 > s2) {
      winnerText = 'გილოცავთ! თქვენ გაიმარჯვეთ ' + s1 + ' - ' + s2 + '!';
    } else if (s2 > s1) {
      winnerText = 'Kidsmart გაიმარჯვა ' + s2 + ' - ' + s1 + '!';
    } else {
      winnerText = 'ფრე! ' + s1 + ' - ' + s2;
    }
    
    gameOverMessage.textContent = winnerText;
    gameOverMessage.style.display = 'block';
    restartBtn.style.display = 'block';
    
    playerTurnMessage.style.display = 'none';
    noMovesMessage.style.display = 'none';
    
    // შევინახოთ ქულები Firebase-ში
    await saveScoreToFirebase(s1 > s2 ? 1 : 0, s2 > s1 ? 1 : 0);
  }
}

// restart game
function restartGame() {
  // Reset board
  board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
  
  // Reset pieces
  playerPieces = clonePiecesForPlayer(1);
  aiPieces = clonePiecesForPlayer(2);
  
  // Reset game state
  selected = null;
  rotation = 0;
  flipped = false;
  turn = 1;
  passed = {1:false, 2:false};
  gameOver = false;
  
  // Update UI
  turnLabel.textContent = 'Player';
  updateCounts();
  renderPieces();
  updateSelectedPreview();
  refreshBoardView();
  updateAiPiecesDisplay();
  
  // Hide messages and restart button
  gameOverMessage.style.display = 'none';
  restartBtn.style.display = 'none';
  updateMessages();
}

// controls: rotate / flip / pass
document.getElementById('rotateBtn').addEventListener('click', ()=>{
  if(!selected || gameOver) return;
  rotation = (rotation + 1) % 4;
  updateSelectedPreview();
  refreshBoardView();
});
document.getElementById('flipBtn').addEventListener('click', ()=>{
  if(!selected || gameOver) return;
  flipped = !flipped;
  updateSelectedPreview();
  refreshBoardView();
});
document.getElementById('passBtn').addEventListener('click', ()=>{
  if(turn !== 1 || gameOver) return;
  passed[1] = true;
  selected = null;
  Array.from(piecesEl.children).forEach(ch=>ch.classList.remove('selected'));
  updateSelectedPreview();
  refreshBoardView();
  nextTurn();
});

// restart button
restartBtn.addEventListener('click', restartGame);

// initialization
async function init(){
  playerPieces = clonePiecesForPlayer(1);
  aiPieces = clonePiecesForPlayer(2);
  
  drawGrid();
  renderPieces();
  updateSelectedPreview();
  updateCounts();
  updateAiPiecesDisplay();
  updateMessages();
  
  // ჩავტვირთოთ ქულები Firebase-დან
  await loadScoresFromFirebase();
}
init();

</script>
</body>
</html>
