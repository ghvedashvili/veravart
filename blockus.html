<!doctype html>
<html lang="ka">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blokus — 2 Players (You vs kidsmart)</title>
<style>
  :root{
    --panel-bg: #fff;
    --board-bg: #f5f7fb;
    --cell: #eef6ff;
    --player1: #ffe9d6;
    --player2: #dff0ff;
    --highlight: #c9f7d0;
    --anchor-highlight: #4ade80;
    --muted: #6b7280;
  }
  *{box-sizing:border-box}
  body{font-family:system-ui,Arial,Helvetica,sans-serif;margin:12px;background:linear-gradient(#fbfdff,#fff);color:#111}
  h1{font-size:18px;margin:6px 0 12px 0}
  .wrap{display:flex;gap:14px;align-items:flex-start;flex-wrap:wrap}
  /* Left: board */
  .left{flex:1;min-width:220px;max-width:680px}
  .panel{background:var(--panel-bg);padding:10px;border-radius:10px;box-shadow:0 6px 20px rgba(9,30,66,0.06)}
  .board-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .muted{color:var(--muted);font-size:13px}
  /* responsive grid: square board that fits container */
  .grid-wrap{display:flex;justify-content:center}
  .grid{
    display:grid;
    grid-template-columns: repeat(10, 1fr);
    grid-auto-rows: 1fr;
    gap:6px;
    width: min(540px, 86vw);
    aspect-ratio: 1 / 1;
    background:var(--board-bg);
    padding:6px;
    border-radius:10px;
  }
  .cell{
    background:var(--cell);
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    color:#555;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
    cursor:pointer;
  }
  .cell.edge{ box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); }
  .cell.player1{ background:var(--player1); }
  .cell.player2{ background:var(--player2); }
  .cell.highlight{ background:var(--highlight) !important; box-shadow: 0 0 0 2px rgba(0,0,0,0.03) inset; }
  /* right: pieces */
  .right{width:320px;min-width:240px}
/* Your Pieces - Kidsmart-ის სტილში */
.pieces {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    margin-top: 6px;
    max-height: 150px;
    overflow: auto;
    padding-bottom: 4px;
}

.piece {
    border-radius: 4px;
    border: 1px solid #e5e7eb;
    padding: 4px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background: white;
    min-width: auto;
}

.piece.used {
    opacity: .35;
    cursor: default;
display:none;
}

.piece.selected {
    outline: 3px solid rgba(34,197,94,0.18);
}

/* წავშალოთ mini გრიდი და გავაკეთოთ Kidsmart-ის სტილში */
.piece .mini {
    display: flex;
    flex-direction: column;
    gap: 1px;
}

.piece .mini .pcell {
    width: auto;
    height: auto;
    border-radius: 1px;
    background: #111;
    opacity: 0.95;
}
  .controls{display:flex;gap:8px;margin-top:8px}
  button{padding:7px 9px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
  button.secondary{background:#f8fafc}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  /* small screens tweaks */
  @media (max-width:520px){
    .right{width:100%}
    .wrap{flex-direction:column}
    .grid{gap:4px}
    .cell{border-radius:5px}
  }
  /* ახალი სტილები kidsmart-ის ფიგურებისთვის */
  .ai-pieces-info {
    margin-top: 2px;
   
    background: #f8fafc;
    border-radius: 6px;
    font-size: 13px;
  }
  .ai-pieces-list {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    margin-top: 6px;
  }
  .ai-piece {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 6px;
    background: white;
    border-radius: 4px;
    border: 1px solid #e5e7eb;
    font-size: 12px;
  }
  /* მოდალის სტილები */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    align-items: center;
    justify-content: center;
  }
  .modal-content {
    background: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    max-width: 300px;
    width: 90%;
  }
  .modal-buttons {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    justify-content: center;
  }
  .modal-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
  .modal-btn.primary {
    background: #3b82f6;
    color: white;
  }
  /* საერთო ანგარიშის კომპაქტური სტილები */
  .score-panel {
    background: #f8fafc;
    padding: 6px 10px;
    border-radius: 6px;
    margin-bottom: 10px;
    border: 1px solid #e5e7eb;
  }
  .score-total {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 13px;
  }
  .score-total span:first-child {
    color: var(--muted);
    font-weight: normal;
  }
  #totalResult {
    font-weight: bold;
    color: #111;
  }
  /* Your Pieces სტილები */
  .pieces-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .pieces-header strong {
    font-size: 14px;
  }
  .pieces-header .muted {
    font-size: 12px;
  }
</style>
</head>
<body>
  <!-- მოდალი თამაშის დასრულებისთვის -->
  <div id="gameOverModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle">თამაში დასრულდა!</h2>
      <div id="modalMessage"></div>
      <div class="score-total" style="margin: 15px 0;">
        საერთო ანგარიში: <span id="modalTotalScore">0 - 0</span>
      </div>
      <div class="modal-buttons">
        <button id="modalRestartBtn" class="modal-btn primary">ხელახლა დაწყება</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="left">
      <div class="panel">
        

        <!-- Kidsmart-ის ფიგურები დაფის ზევით -->
        <div class="ai-pieces-info">
          <div><strong>Kidsmart-ის დარჩენილი ფიგურები:</strong></div>
          <div id="aiPiecesList" class="ai-pieces-list"></div>
        </div>

        <div class="board-head">
  
          <div class="muted">Turn: <span id="turnLabel">Player</span></div>
        </div>

        <div class="grid-wrap">
          <div id="grid" class="grid" aria-hidden="false"></div>
        </div>

        <!--<div style="margin-top:10px" class="muted">-->
        <!--  Player pieces left: <span id="pCount">0</span> — kidsmart pieces left: <span id="aiCount">0</span>-->
        <!--</div>-->

        <button id="restartBtn" class="restart-btn">თამაშის ხელახლა დაწყება</button>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <!--<div><strong>Selected piece</strong></div>-->
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <div id="selectedPreview" class="piece" style="min-width:120px;min-height:58px">No piece</div>
          <div style="display:flex;gap:6px">
            <button id="rotateBtn">Rotate ⟳</button>
            <button id="flipBtn">Flip ↔</button>
            <button id="passBtn">Pass turn</button>
          </div>
        </div>

        <hr style="margin:10px 0">

        <!-- Your Pieces ერთ ხაზზე -->
        <div class="pieces-header">
          <strong>Your Pieces</strong>
          <span class="muted">(tap to select)</span>
        </div>
        <div id="pieces" class="pieces"></div>

        <hr style="margin:10px 0">

        <!--<div><strong>Instructions</strong></div>-->
        <!--<div class="muted" style="margin-top:6px">-->
        <!--  აირჩიე ფიგურა — დაფაზე მაშინვე გამოჩნდება ყველა შესაძლო ადგილი, სადაც შეგიძლია დადება (მწვანე). დააჭირე მონიშნულ უჯრას და ფიგურა დაიდება. პირველი შენიანი ნაბიჯი უნდა შეეხოს ზედა-მარცხით კუთხეს. (მობილურზეც მუშაობს — tap only).-->
        <!--</div>-->
        <!-- საერთო ანგარიში -->
        
      </div>
    </div>
  </div>
<div class="score-panel">
          <div class="score-total">
            <span>საერთო ანგარიში:</span><hr>
            <span id="totalResult">0 - 0</span>
          </div>
        </div>
  <!--<footer>Simple Blokus-like game — AI (kidsmart) uses improved strategy.</footer>-->

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyD0z4y5Q7Q5Z3Q3Q3Q3Q3Q3Q3Q3Q3Q3Q",
  authDomain: "newspaperveravart-default-rtdb.firebaseapp.com",
  databaseURL: "https://newspaperveravart-default-rtdb.firebaseio.com",
  projectId: "newspaperveravart",
  storageBucket: "newspaperveravart.appspot.com",
  messagingSenderId: "1234567890",
  appId: "1:1234567890:web:1234567890abcdef"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// board size - 7x7 დაფა
const ROWS = 10, COLS = 10;
const gridEl = document.getElementById('grid');
const piecesEl = document.getElementById('pieces');
const selectedPreview = document.getElementById('selectedPreview');
const turnLabel = document.getElementById('turnLabel');
const pCountEl = document.getElementById('pCount');
const aiCountEl = document.getElementById('aiCount');
const aiPiecesListEl = document.getElementById('aiPiecesList');
const restartBtn = document.getElementById('restartBtn');
const totalResultEl = document.getElementById('totalResult');
const gameOverModal = document.getElementById('gameOverModal');
const modalTitle = document.getElementById('modalTitle');
const modalMessage = document.getElementById('modalMessage');
const modalTotalScore = document.getElementById('modalTotalScore');
const modalRestartBtn = document.getElementById('modalRestartBtn');
restartBtn.style.display = 'none';
let board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
let cells = [];

const BASE_PIECES = [
  // არსებული ფიგურები
  {id:'1', name:'Dot', shape:[[0,0]]},
  {id:'2', name:'Domino', shape:[[0,0],[0,1]]},
  {id:'3', name:'L3', shape:[[0,0],[1,0],[0,1]]},
  {id:'4', name:'I3', shape:[[0,0],[0,1],[0,2]]},
  {id:'5', name:'Square', shape:[[0,0],[1,0],[0,1],[1,1]]},
  
  // ახალი ფიგურები
  
  {id:'7', name:'Corner', shape:[[0,0],[0,1],[1,1],[1,2]]}, // დიდი კუთხე
  {id:'8', name:'Tower', shape:[[0,0],[0,1],[0,2],[1,0],[1,2]]}, // კოშკი

  {id:'10', name:'Hook', shape:[[0,0],[0,1],[0,2],[1,0],[2,0]]}, // კაკვი
  {id:'11', name:'Pyramid', shape:[[0,0],[1,0],[2,0],[1,1],[1,2]]}, // პირამიდა
  {id:'12', name:'Diamond', shape:[[0,1],[1,0],[1,1],[1,2],[2,1]]}, // ალმასი
  {id:'13', name:'Stairs', shape:[[0,0],[1,0],[1,1],[2,1],[2,2]]}, // კიბე

];

function clonePiecesForPlayer(player){
  return BASE_PIECES.map(p=>({
    id: p.id+'-'+player,
    name: p.name,
    owner: player,
    used: false,
    shape: p.shape.map(s=>[s[0], s[1]])
  }));
}

let playerPieces, aiPieces;
let selected = null;
let rotation = 0;
let flipped = false;
let turn = 1;
let passed = {1:false, 2:false};
let gameOver = false;
let totalScores = { player: 0, ai: 0 };
const startCorners = {1: [0,0], 2: [COLS-1, ROWS-1]};

function drawGrid(){
  gridEl.innerHTML = '';
  cells = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d = document.createElement('div');
      d.className = 'cell';
      if(r===0||c===0||r===ROWS-1||c===COLS-1) d.classList.add('edge');
      d.dataset.r = r; d.dataset.c = c;
      d.addEventListener('click', ()=>onCellClick(r,c));
      gridEl.appendChild(d);
      cells.push(d);
    }
  }
  refreshBoardView();
}

function updateMessages() {
  if (gameOver) return;
  
  if (turn === 1) {
    if (!playerHasValidMoves()) {
      // თუ მოთამაშეს არ აქვს სვლა, ავტომატურად გადავიდეთ AI-ზე
      setTimeout(() => {
        if (!gameOver && turn === 1) {
          nextTurn();
        }
      }, 1000);
    }
  }
}

// და გამოიძახე updateMessages() refreshBoardView()-ში
function refreshBoardView(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const el = cells[idx];
      el.classList.remove('player1','player2','highlight','piece-part','anchor-part');
      el.style.background = '';
      
      if(board[r][c]===1) el.classList.add('player1');
      if(board[r][c]===2) el.classList.add('player2');
    }
  }
  
  if(turn===1 && selected){
    highlightValidMoves();
  }
  
  // შეამოწმე სვლის შესაძლებლობა
  updateMessages();
}

function rotateShape(shape){
  return shape.map(([x,y])=>[y, -x]);
}

function flipShape(shape){
  return shape.map(([x,y])=>[-x, y]);
}

function normalize(shape){
  const xs = shape.map(s=>s[0]), ys = shape.map(s=>s[1]);
  const minx = Math.min(...xs), miny = Math.min(...ys);
  return shape.map(([x,y])=>[x-minx, y-miny]);
}

function canonicalVariants(shape){
  const variants = [];
  let s = shape.map(a=>[a[0],a[1]]);
  for(let i=0;i<4;i++){
    s = rotateShape(s);
    variants.push(normalize(s.map(a=>[a[0],a[1]])));
    variants.push(normalize(flipShape(s.map(a=>[a[0],a[1]]))));
  }
  const set = new Set();
  const out = [];
  for(const v of variants){
    const key = JSON.stringify(v.slice().sort((a,b)=>a[0]-b[0]||a[1]-b[1]));
    if(!set.has(key)){ set.add(key); out.push(v); }
  }
  return out;
}

function canPlaceAt(owner, shape, baseR, baseC){
  const ownerArr = owner===1 ? playerPieces : aiPieces;
  const madeAny = ownerArr.some(p=>p.used);
  const isFirstMove = !madeAny;

  let touchesCorner = false;
  for(const [x,y] of shape){
    const r = baseR + y, c = baseC + x;
    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
    if(board[r][c] !== 0) return false;
    const edges = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [ex,ey] of edges){
      const nr = r + ey, nc = c + ex;
      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS){
        if(board[nr][nc] === owner) return false;
      }
    }
    const corners = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [cx,cy] of corners){
      const nr = r + cy, nc = c + cx;
      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS){
        if(board[nr][nc] === owner) touchesCorner = true;
      }
    }
  }

  if(isFirstMove){
    const [sc, sr] = startCorners[owner];
    let coversStart = false;
    for(const [x,y] of shape){
      if(baseR + y === sr && baseC + x === sc) coversStart = true;
    }
    return coversStart;
  }
  return touchesCorner;
}

function placePiece(owner, pieceId, shape, baseR, baseC){
  for(const [x,y] of shape){
    board[baseR + y][baseC + x] = owner;
  }
  const arr = owner===1 ? playerPieces : aiPieces;
  const p = arr.find(pp => pp.id === pieceId);
  if(p) p.used = true;
  
  updateAiPiecesDisplay();
  renderPieces();
}

function renderPieces(){
    piecesEl.innerHTML = '';
    playerPieces.forEach(p=>{
        const b = document.createElement('div');
        b.className = 'piece' + (p.used ? ' used' : '');
        b.dataset.pieceId = p.id;
        
        // Kidsmart-ის სტილის პრევიუ
        const norm = normalize(p.shape);
        const preview = document.createElement('div');
        preview.style.display = 'flex';
        preview.style.flexDirection = 'column';
        preview.style.gap = '1px';
        
        const maxX = Math.max(...norm.map(s => s[0]));
        const maxY = Math.max(...norm.map(s => s[1]));
        
        for (let y = 0; y <= maxY; y++) {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.gap = '1px';
            
            for (let x = 0; x <= maxX; x++) {
                const cell = document.createElement('div');
                cell.style.width = '8px';
                cell.style.height = '8px';
                cell.style.borderRadius = '1px';
                cell.style.backgroundColor = '#111';
                cell.style.opacity = norm.some(a => a[0] === x && a[1] === y) ? '0.95' : '0';
                row.appendChild(cell);
            }
            preview.appendChild(row);
        }
        
        b.appendChild(preview);
        
        // click handler
        b.addEventListener('click', ()=>{
            if(p.used || turn !== 1 || gameOver) return;
            selectPiece(p);
            // update selected class visuals
            Array.from(piecesEl.children).forEach(ch => ch.classList.remove('selected'));
            b.classList.add('selected');
        });
        piecesEl.appendChild(b);
    });
}

function updateAiPiecesDisplay(){
  aiPiecesListEl.innerHTML = '';
  const unusedAiPieces = aiPieces.filter(p => !p.used);
  
  if (unusedAiPieces.length === 0) {
    aiPiecesListEl.innerHTML = '<span style="color: var(--muted)">ყველა ფიგურა გამოყენებულია</span>';
    return;
  }
  
  unusedAiPieces.forEach(p => {
    const pieceEl = document.createElement('div');
    pieceEl.className = 'ai-piece';
    
    const norm = normalize(p.shape);
    const preview = document.createElement('div');
    preview.style.display = 'flex';
    preview.style.flexDirection = 'column';
    preview.style.gap = '1px';
    
    const maxX = Math.max(...norm.map(s => s[0]));
    const maxY = Math.max(...norm.map(s => s[1]));
    
    for (let y = 0; y <= maxY; y++) {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.gap = '1px';
      
      for (let x = 0; x <= maxX; x++) {
        const cell = document.createElement('div');
        cell.style.width = '6px';
        cell.style.height = '6px';
        cell.style.borderRadius = '1px';
        cell.style.backgroundColor = '#3b82f6';
        cell.style.opacity = norm.some(a => a[0] === x && a[1] === y) ? '1' : '0';
        row.appendChild(cell);
      }
      preview.appendChild(row);
    }
    
    pieceEl.appendChild(preview);
    
    // const nameSpan = document.createElement('span');
    // nameSpan.textContent = p.name;
    // pieceEl.appendChild(nameSpan);
    
    aiPiecesListEl.appendChild(pieceEl);
  });
}

function selectPiece(p){
  selected = { pieceId: p.id, originalShape: p.shape.map(s=>[s[0], s[1]]), owner: 1 };
  rotation = 0; flipped = false;
  updateSelectedPreview();
  refreshBoardView();
}

function getTransformedShape(){
  if(!selected) return null;
  let s = selected.originalShape.map(a=>[a[0], a[1]]);
  for(let i=0;i<rotation;i++) s = rotateShape(s);
  if(flipped) s = flipShape(s);
  s = normalize(s);
  return s;
}

function updateSelectedPreview(){
  selectedPreview.innerHTML = '';
  if(!selected){ selectedPreview.textContent = '(no piece)'; return; }
  const v = getTransformedShape();
  const w = Math.max(...v.map(s=>s[0]))+1, h = Math.max(...v.map(s=>s[1]))+1;
  const wrap = document.createElement('div'); wrap.style.display='grid'; wrap.style.gap='3px';
  wrap.style.gridTemplateColumns = `repeat(${w}, 14px)`;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const d = document.createElement('div');
      d.style.width='14px'; d.style.height='14px'; d.style.borderRadius='2px';
      if(v.some(a=>a[0]===x && a[1]===y)){ d.style.background='#111'; d.style.opacity='0.9'; }
      else { d.style.background='#111'; d.style.opacity='0.06'; }
      wrap.appendChild(d);
    }
  }
  selectedPreview.appendChild(wrap);
}

function highlightValidMoves(){
  cells.forEach(c => {
    c.classList.remove('piece-part', 'anchor-part');
    c.style.background = '';
  });
  
  if(!selected) return;
  const shape = getTransformedShape();
  
  let anchorX = Infinity, anchorY = Infinity;
  for(const [x,y] of shape){
    if(y < anchorY || (y === anchorY && x < anchorX)) {
      anchorY = y;
      anchorX = x;
    }
  }
  
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(canPlaceAt(1, shape, r, c)){
        const anchorR = r + anchorY;
        const anchorC = c + anchorX;
        
        for(const [x,y] of shape){
          const pieceR = r + y;
          const pieceC = c + x;
          if(pieceR >= 0 && pieceR < ROWS && pieceC >= 0 && pieceC < COLS){
            const idx = pieceR*COLS + pieceC;
            if(pieceR === anchorR && pieceC === anchorC) {
              cells[idx].classList.add('anchor-part');
              cells[idx].style.background = 'var(--anchor-highlight)';
            } else {
              cells[idx].classList.add('piece-part');
              cells[idx].style.background = 'var(--highlight)';
            }
          }
        }
      }
    }
  }
}

function onCellClick(r,c){
  if (gameOver) return;
  
  if(turn === 1 && selected){
    const shape = getTransformedShape();
    
    let anchorX = Infinity, anchorY = Infinity;
    for(const [x,y] of shape){
      if(y < anchorY || (y === anchorY && x < anchorX)) {
        anchorY = y;
        anchorX = x;
      }
    }
    
    const baseR = r - anchorY;
    const baseC = c - anchorX;
    
    if(baseR >= 0 && baseR < ROWS && baseC >= 0 && baseC < COLS && 
       canPlaceAt(1, shape, baseR, baseC)) {
      
      placePiece(1, selected.pieceId, shape, baseR, baseC);
      selected = null;
      Array.from(piecesEl.children).forEach(ch=>ch.classList.remove('selected'));
      updateSelectedPreview();
      //updateCounts();
      refreshBoardView();
      passed[1] = false;
      nextTurn();
      return;
    }
  }
}

function playerHasValidMoves() {
  const available = playerPieces.filter(p => !p.used);
  for(const p of available){
    const variants = canonicalVariants(p.shape);
    for(const v of variants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(1, v, r, c)){
            return true;
          }
        }
      }
    }
  }
  return false;
}

function aiHasValidMoves() {
  const available = aiPieces.filter(p => !p.used);
  for(const p of available){
    const variants = canonicalVariants(p.shape);
    for(const v of variants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(2, v, r, c)){
            return true;
          }
        }
      }
    }
  }
  return false;
}

function nextTurn(){
  if (gameOver) return;
  
  // შეამოწმეთ თუ მოთამაშეს არ აქვს სვლა
  if (turn === 1 && !playerHasValidMoves()) {
    passed[1] = true;
    // ავტომატურად გადავიდეთ AI-ის სვლაზე
    turn = 2;
    turnLabel.textContent = 'kidsmart (AI)';
    setTimeout(()=> aiMove(), 300);
    checkEnd();
    return;
  }
  
  // შეამოწმეთ თუ AI-ს არ აქვს სვლა
  if (turn === 2 && !aiHasValidMoves()) {
    passed[2] = true;
  }
  
  turn = (turn === 1) ? 2 : 1;
  turnLabel.textContent = (turn === 1) ? 'Player' : 'kidsmart (AI)';
  
  if(turn === 2){
    setTimeout(()=> aiMove(), 300);
  } else {
    refreshBoardView();
  }
  checkEnd();
}

// function updateCounts(){
//   pCountEl.textContent = playerPieces.filter(p=>!p.used).length;
//   aiCountEl.textContent = aiPieces.filter(p=>!p.used).length;
// }

function aiMove(){
  if (gameOver) return;
  
  const available = aiPieces.filter(p=>!p.used);
  const shuffledPieces = [...available].sort(() => Math.random() - 0.5);
  
  let bestMove = null;
  let bestScore = -Infinity;
  let allValidMoves = [];
  
  for(const p of shuffledPieces){
    const variants = canonicalVariants(p.shape);
    const shuffledVariants = [...variants].sort(() => Math.random() - 0.5);
    
    for(const v of shuffledVariants){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlaceAt(2, v, r, c)){
            const score = evaluateMove(2, v, r, c);
            allValidMoves.push({piece: p, shape: v, r, c, score});
            
            if(score > bestScore){
              bestScore = score;
              bestMove = {piece: p, shape: v, r, c};
            }
          }
        }
      }
    }
  }
  
  if(allValidMoves.length === 0){
    passed[2] = true;
    nextTurn();
    return;
  }
  
  const isFirstMove = !aiPieces.some(p => p.used);
  
  if(isFirstMove && allValidMoves.length > 1){
    const topMoves = allValidMoves.filter(move => move.score >= bestScore - 10);
    const randomMove = topMoves[Math.floor(Math.random() * topMoves.length)];
    bestMove = randomMove;
  } else if(!isFirstMove && allValidMoves.length > 3){
    if(Math.random() < 0.2){
      const randomMove = allValidMoves[Math.floor(Math.random() * allValidMoves.length)];
      bestMove = randomMove;
    }
  }
  
  if(bestMove){
    placePiece(2, bestMove.piece.id, bestMove.shape, bestMove.r, bestMove.c);
   // updateCounts();
    refreshBoardView();
    passed[2] = false;
    nextTurn();
  } else {
    passed[2] = true;
    nextTurn();
  }
}

function evaluateMove(owner, shape, baseR, baseC) {
  let score = 0;
  score += shape.length * 10;
  
  const centerR = Math.floor(ROWS / 2);
  const centerC = Math.floor(COLS / 2);
  let avgR = 0, avgC = 0;
  
  for(const [x,y] of shape){
    avgR += baseR + y;
    avgC += baseC + x;
  }
  avgR /= shape.length;
  avgC /= shape.length;
  
  const distFromCenter = Math.sqrt(
    Math.pow(avgR - centerR, 2) + Math.pow(avgC - centerC, 2)
  );
  score -= distFromCenter * 2;
  
  let opponentProximity = 0;
  const opponent = owner === 1 ? 2 : 1;
  
  for(const [x,y] of shape){
    const r = baseR + y, c = baseC + x;
    for(let dr = -2; dr <= 2; dr++){
      for(let dc = -2; dc <= 2; dc++){
        const nr = r + dr, nc = c + dc;
        if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS){
          if(board[nr][nc] === opponent){
            opponentProximity += 1 / (Math.abs(dr) + Math.abs(dc) + 1);
          }
        }
      }
    }
  }
  score += opponentProximity * 5;
  
  let cornerScore = 0;
  const corners = [[0,0], [0,ROWS-1], [COLS-1,0], [COLS-1,ROWS-1]];
  for(const [cx,cy] of corners){
    for(const [x,y] of shape){
      if(baseC + x === cx && baseR + y === cy){
        cornerScore += 20;
      }
    }
  }
  score += cornerScore;
  
  return score;
}

async function saveScoreToFirebase(playerScore, aiScore) {
  try {
    const gameResult = {
      player: playerScore,
      ai: aiScore,
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      winner: playerScore > aiScore ? 'player' : playerScore < aiScore ? 'ai' : 'tie'
    };
    
    const newGameRef = database.ref('blokus/games').push();
    await newGameRef.set(gameResult);
    
    const totalRef = database.ref('blokus/totals');
    const snapshot = await totalRef.once('value');
    const currentTotals = snapshot.val() || { player: 0, ai: 0 };
    
    if (playerScore > aiScore) {
      currentTotals.player += 1;
    } else if (aiScore > playerScore) {
      currentTotals.ai += 1;
    }
    
    await totalRef.set(currentTotals);
    
    totalScores = currentTotals;
    updateTotalScoresDisplay();
    
    return true;
  } catch (error) {
    console.error('Error saving score to Firebase:', error);
    return false;
  }
}

async function loadScoresFromFirebase() {
  try {
    const totalRef = database.ref('blokus/totals');
    const snapshot = await totalRef.once('value');
    const totals = snapshot.val() || { player: 0, ai: 0 };
    
    totalScores = totals;
    updateTotalScoresDisplay();
    
    return true;
  } catch (error) {
    console.error('Error loading scores from Firebase:', error);
    return false;
  }
}

function updateTotalScoresDisplay() {
  totalResultEl.textContent = `მოთამაშე ${totalScores.player} - ${totalScores.ai} kidsmart`;
}

function showGameOverModal(s1, s2) {
  let winnerText = '';
  if (s1 > s2) {
    winnerText = 'გილოცავთ! თქვენ გაიმარჯვეთ ' + s1 + ' - ' + s2 + '!';
    modalTitle.textContent = 'გამარჯვება!';
  } else if (s2 > s1) {
    winnerText = 'Kidsmart გაიმარჯვა ' + s2 + ' - ' + s1 + '!';
    modalTitle.textContent = 'წაგება';
  } else {
    winnerText = 'ფრე! ' + s1 + ' - ' + s2;
    modalTitle.textContent = 'ფრე!';
  }
  
  modalMessage.textContent = winnerText;
  modalTotalScore.textContent = `მოთამაშე ${totalScores.player} - ${totalScores.ai} kidsmart`;
  gameOverModal.style.display = 'flex';
}

async function checkEnd(){
  const bothPassed = passed[1] && passed[2];
  const noPieces = playerPieces.every(p=>p.used) && aiPieces.every(p=>p.used);
  
  if(bothPassed || noPieces){
    gameOver = true;
    let s1 = 0, s2 = 0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(board[r][c]===1) s1++;
        if(board[r][c]===2) s2++;
      }
    }
    
    await saveScoreToFirebase(s1 > s2 ? 1 : 0, s2 > s1 ? 1 : 0);
    setTimeout(() => showGameOverModal(s1, s2), 500);
  }
}

function restartGame() {
  board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
  playerPieces = clonePiecesForPlayer(1);
  aiPieces = clonePiecesForPlayer(2);
  selected = null;
  rotation = 0;
  flipped = false;
  turn = 1;
  passed = {1:false, 2:false};
  gameOver = false;
  
  turnLabel.textContent = 'Player';
  //updateCounts();
  renderPieces();
  updateSelectedPreview();
  refreshBoardView();
  updateAiPiecesDisplay();
  
  gameOverModal.style.display = 'none';
  restartBtn.style.display = 'none';
}

document.getElementById('rotateBtn').addEventListener('click', ()=>{
  if(!selected || gameOver) return;
  rotation = (rotation + 1) % 4;
  updateSelectedPreview();
  refreshBoardView();
});
document.getElementById('flipBtn').addEventListener('click', ()=>{
  if(!selected || gameOver) return;
  flipped = !flipped;
  updateSelectedPreview();
  refreshBoardView();
});
document.getElementById('passBtn').addEventListener('click', ()=>{
  if(turn !== 1 || gameOver) return;
  passed[1] = true;
  selected = null;
  Array.from(piecesEl.children).forEach(ch=>ch.classList.remove('selected'));
  updateSelectedPreview();
  refreshBoardView();
  nextTurn();
});

restartBtn.addEventListener('click', restartGame);
modalRestartBtn.addEventListener('click', restartGame);

async function init(){
  playerPieces = clonePiecesForPlayer(1);
  aiPieces = clonePiecesForPlayer(2);
  
  drawGrid();
  renderPieces();
  updateSelectedPreview();
 // updateCounts();
  updateAiPiecesDisplay();
  
  await loadScoresFromFirebase();
}
init();
</script>
</body>
</html>
